Sync with HEAD at 23 August 2011, fixing important GL bugs
--- a/ChangeLog.txt
+++ b/ChangeLog.txt
@@ -1,8 +1,30 @@
 ===============================================================================
+2.3
+===============================================================================
+[1]
+Fix regression bug whereby GLXSpheres would ignore the first argument after
+-fs.
+-------------------------------------------------------------------------------
+[2]
+glXChooseFBConfig() and glXChooseFBConfigSGIX() were erroneously returning an
+error when a NULL attribute list argument was passed to them.  They now behave
+correctly.
+-------------------------------------------------------------------------------
+[3]
+Fixed regression issue whereby VirtualGL would deadlock when using the X11
+Transport with a remote X connection.
+-------------------------------------------------------------------------------
+[4]
+Fixed a GL_INVALID_OPERATION error that would occur after a call to
+glXSwapBuffers() when a context with the OpenGL Core Profile was being used.
+-------------------------------------------------------------------------------
+
+
+===============================================================================
 2.3 beta1
 ===============================================================================
 [1]
-Re-fix issue that caused MainWin-based applications to hang.  This was
+Re-fixed issue that caused MainWin-based applications to hang.  This was
 initially fixed in VGL 2.1 final, but it was re-broken by the rewrite of the
 global faker configuration routines in VGL 2.2.
 -------------------------------------------------------------------------------
diff --git a/mesademos/glxspheres.c b/mesademos/glxspheres.c
index c6d1084..9e7d715 100755
--- a/mesademos/glxspheres.c
+++ b/mesademos/glxspheres.c
@@ -528,15 +528,6 @@ int main(int argc, char **argv)
 				printf("Window dimensions: %d x %d\n", width, height);
 			}
 		}
-		if(!strnicmp(argv[i], "-f", 2) && i<argc-1)
-		{ 
-			int mf=atoi(argv[++i]); 
-			if(mf>0)
-			{
-				maxframes=mf;
-				printf("Number of frames to render: %d\n", maxframes);
-			}
-		}
 		if(!strnicmp(argv[i], "-p", 2) && i<argc-1)
 		{
 			int npolys=atoi(argv[++i]);
@@ -546,7 +537,16 @@ int main(int argc, char **argv)
 				if(slices<1) slices=stacks=1;
 			}
 		}
-		if(!stricmp(argv[i], "-fs")) fullscreen=1;
+		if(!strnicmp(argv[i], "-fs", 3)) fullscreen=1;
+		else if(!strnicmp(argv[i], "-f", 2) && i<argc-1)
+		{ 
+			int mf=atoi(argv[++i]); 
+			if(mf>0)
+			{
+				maxframes=mf;
+				printf("Number of frames to render: %d\n", maxframes);
+			}
+		}
 		if(!strnicmp(argv[i], "-s", 2))
 		{
 			rgbattribs[10]=GLX_STEREO;
diff --git a/rr/CMakeLists.txt b/rr/CMakeLists.txt
index 69e987c..1888d29 100644
--- a/rr/CMakeLists.txt
+++ b/rr/CMakeLists.txt
@@ -17,6 +17,11 @@ include_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR})
 
 if(VGL_BUILDSERVER)
 
+	set(FBXFAKERLIB fbx-faker)
+	if(VGL_USEXV)
+		set(FBXFAKERLIB ${FBXFAKERLIB};fbxv)
+	endif()
+
 	get_directory_property(DEFS_PROP COMPILE_DEFINITIONS)
 	foreach(def ${DEFS_PROP})
 		set(DEFINES ${DEFINES};-D${def})
@@ -42,8 +47,8 @@ if(VGL_BUILDSERVER)
 	else()
 		set_target_properties(rrfaker PROPERTIES LINK_FLAGS "-z defs")
 	endif()
-	target_link_libraries(rrfaker rrutil ${FBXLIB} ${TJPEG_LIBRARY} rrsocket m
-		${OPENGL_gl_LIBRARY} dl)
+	target_link_libraries(rrfaker rrutil ${FBXFAKERLIB} ${TJPEG_LIBRARY} rrsocket
+		m ${OPENGL_gl_LIBRARY} dl)
 	if(CMAKE_SYSTEM_NAME STREQUAL "SunOS" AND CMAKE_COMPILER_IS_GNUCXX)
 		# For some reason, on SunOS/GCC CMake tries to use the C compiler to link
 		# C++ shared libs.  Grrr...
@@ -176,8 +181,7 @@ if(VGL_BUILDSERVER)
 	endif()
 
 	add_library(vgltrans_test2 SHARED testplugin2.cpp rrblitter.cpp)
-	set_target_properties(vgltrans_test2 PROPERTIES LINK_FLAGS "-z defs")
-	target_link_libraries(vgltrans_test2 rrutil ${FBXLIB} ${TJPEG_LIBRARY})
+	target_link_libraries(vgltrans_test2 rrutil ${FBXFAKERLIB} ${TJPEG_LIBRARY})
 	if(CMAKE_SYSTEM_NAME STREQUAL "SunOS" AND CMAKE_COMPILER_IS_GNUCXX)
 		target_link_libraries(vgltrans_test2 stdc++)
 	endif()
diff --git a/rr/faker-glx.cpp b/rr/faker-glx.cpp
index 91837d5..ab4d089 100644
--- a/rr/faker-glx.cpp
+++ b/rr/faker-glx.cpp
@@ -81,7 +81,8 @@ static GLXFBConfig _MatchConfig(Display *dpy, XVisualInfo *vis)
 
 extern "C" {
 
-GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen, const int *attrib_list, int *nelements)
+GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen,
+	const int *attrib_list, int *nelements)
 {
 	GLXFBConfig *configs=NULL;
 	TRY();
@@ -128,10 +129,13 @@ GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen, const int *attrib_list,
 		}
 	}
 
-	int depth=24, c_class=TrueColor, level=0, stereo=0, trans=0;
-	if(!attrib_list || !nelements) return NULL;
+	int depth=24, c_class=TrueColor, level=0, stereo=0, trans=0, temp;
+	if(!nelements) nelements=&temp;
 	*nelements=0;
-	configs=__vglConfigsFromVisAttribs(attrib_list, depth, c_class, level,
+	if(!attrib_list)
+		configs=_glXChooseFBConfig(_localdpy, DefaultScreen(_localdpy),
+			attrib_list, nelements);
+	else configs=__vglConfigsFromVisAttribs(attrib_list, depth, c_class, level,
 		stereo, trans, *nelements, true);
 	if(configs && *nelements)
 	{
@@ -149,9 +153,11 @@ GLXFBConfig *glXChooseFBConfig(Display *dpy, int screen, const int *attrib_list,
 }
 
 #ifdef SUNOGL
-GLXFBConfigSGIX *glXChooseFBConfigSGIX (Display *dpy, int screen, const int *attrib_list, int *nelements)
+GLXFBConfigSGIX *glXChooseFBConfigSGIX (Display *dpy, int screen,
+	const int *attrib_list, int *nelements)
 #else
-GLXFBConfigSGIX *glXChooseFBConfigSGIX (Display *dpy, int screen, int *attrib_list, int *nelements)
+GLXFBConfigSGIX *glXChooseFBConfigSGIX (Display *dpy, int screen,
+	int *attrib_list, int *nelements)
 #endif
 {
 	return glXChooseFBConfig(dpy, screen, attrib_list, nelements);
diff --git a/rr/faker-hash.h b/rr/faker-hash.h
index e0c678a..10fb93f 100644
--- a/rr/faker-hash.h
+++ b/rr/faker-hash.h
@@ -58,7 +58,7 @@ class _hashclass
 			return 1;
 		}
 
-		_hashvaluetype find(_hashkeytype1 key1, _hashkeytype2 key2, bool useref=false)
+		_hashvaluetype find(_hashkeytype1 key1, _hashkeytype2 key2)
 		{
 			_hashclassstruct *ptr=NULL;
 //			if(!key1) _throw("Invalid argument");
diff --git a/rr/faker-mapfile.c b/rr/faker-mapfile.c
index 7ad9ead..78c8a79 100755
--- a/rr/faker-mapfile.c
+++ b/rr/faker-mapfile.c
@@ -126,11 +126,7 @@
 		XSolarisGetVisualGamma;
 		#endif
 
-		__XFree;
-		__XGetGeometry;
-		__XNextEvent;
-		__XOpenDisplay;
-		__XCreateWindow;
+		__XCopyArea;
 
 		_vgl_dlopen;
 
diff --git a/rr/faker.cpp b/rr/faker.cpp
index 2cd1363..d3b6a59 100644
--- a/rr/faker.cpp
+++ b/rr/faker.cpp
@@ -893,10 +893,7 @@ GLXContext glXCreateContext(Display *dpy, XVisualInfo *vis,
 	GLXFBConfig c;
 	if(!(c=_MatchConfig(dpy, vis)))
 		_throw("Could not obtain Pbuffer-capable RGB visual on the server");
-	int render_type=__vglServerVisualAttrib(c, GLX_RENDER_TYPE);
-	ctx=_glXCreateNewContext(_localdpy, c,
-		render_type==GLX_COLOR_INDEX_BIT? GLX_COLOR_INDEX_TYPE:GLX_RGBA_TYPE,
-			share_list, direct);
+	ctx=_glXCreateNewContext(_localdpy, c, GLX_RGBA_TYPE, share_list, direct);
 	if(ctx)
 	{
 		if(!_glXIsDirect(_localdpy, ctx) && direct)
@@ -1053,12 +1050,7 @@ GLXContext glXCreateNewContext(Display *dpy, GLXFBConfig config,
 		return ctx;
 	}
 
-	if(__vglServerVisualAttrib(config, GLX_RENDER_TYPE)==GLX_COLOR_INDEX_BIT)
-		render_type=GLX_COLOR_INDEX_TYPE;
-	else
-		render_type=GLX_RGBA_TYPE;
-
-	ctx=_glXCreateNewContext(_localdpy, config, render_type, share_list, direct);
+	ctx=_glXCreateNewContext(_localdpy, config, GLX_RGBA_TYPE, share_list, direct);
 	if(ctx)
 	{
 		if(!_glXIsDirect(_localdpy, ctx) && direct)
@@ -1196,31 +1188,16 @@ GLXContext glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config,
 		return ctx;
 	}
 
-	int render_type;
-	if(__vglServerVisualAttrib(config, GLX_RENDER_TYPE)==GLX_COLOR_INDEX_BIT)
-		render_type=GLX_COLOR_INDEX_TYPE;
-	else
-		render_type=GLX_RGBA_TYPE;
-
-	int newattribs[257]={None}, n=0;
 	if(attribs)
 	{
 		for(int i=0; attribs[i]!=None && i<=254; i+=2)
 		{
-			if(attribs[i]!=GLX_RENDER_TYPE)
-			{
-				newattribs[n++]=attribs[i];  newattribs[n++]=attribs[i+1];
-			}
+			if(attribs[i]==GLX_RENDER_TYPE) ((int *)attribs)[i+1]=GLX_RGBA_TYPE;
 		}
 	}
-	if(n<=254)
-	{
-		newattribs[n++]=GLX_RENDER_TYPE;  newattribs[n++]=render_type;
-	}
-	newattribs[n]=None;
 
 	ctx=_glXCreateContextAttribsARB(_localdpy, config, share_context, direct,
-		newattribs);
+		attribs);
 	if(ctx)
 	{
 		if(!_glXIsDirect(_localdpy, ctx) && direct)
diff --git a/rr/pbdrawable.cpp b/rr/pbdrawable.cpp
index 113947d..294fc61 100644
--- a/rr/pbdrawable.cpp
+++ b/rr/pbdrawable.cpp
@@ -202,7 +202,9 @@ Drawable pbdrawable::getx11drawable(void)
 void pbdrawable::readpixels(GLint x, GLint y, GLint w, GLint pitch, GLint h,
 	GLenum format, int ps, GLubyte *bits, GLint buf, bool usepbo, bool stereo)
 {
-	GLint readbuf=GL_BACK, oldrendermode=GL_RENDER;
+	GLint readbuf=GL_BACK, oldrendermode=GL_RENDER, oldpackalignment=1;
+	GLfloat oldredscale=1.0, oldredbias=0.0, oldgreenscale=1.0, oldgreenbias=0.0,
+		oldbluescale=1.0, oldbluebias=0.0, oldalphascale=1.0, oldalphabias=0.0;
 	GLint fbr=0, fbw=0;
 	#ifdef GL_VERSION_1_5
 	static GLuint pbo=0;  int boundbuffer=0;
@@ -225,14 +227,21 @@ void pbdrawable::readpixels(GLint x, GLint y, GLint w, GLint pitch, GLint h,
 
 	glReadBuffer(buf);
 	glRenderMode(GL_RENDER);
-	glPushClientAttrib(GL_CLIENT_PIXEL_STORE_BIT);
 
+	_glGetIntegerv(GL_PACK_ALIGNMENT, &oldpackalignment);
 	if(pitch%8==0) glPixelStorei(GL_PACK_ALIGNMENT, 8);
 	else if(pitch%4==0) glPixelStorei(GL_PACK_ALIGNMENT, 4);
 	else if(pitch%2==0) glPixelStorei(GL_PACK_ALIGNMENT, 2);
 	else if(pitch%1==0) glPixelStorei(GL_PACK_ALIGNMENT, 1);
 
-	glPushAttrib(GL_PIXEL_MODE_BIT);
+	_glGetFloatv(GL_RED_SCALE, &oldredscale);
+	_glGetFloatv(GL_RED_BIAS, &oldredbias);
+	_glGetFloatv(GL_GREEN_SCALE, &oldgreenscale);
+	_glGetFloatv(GL_GREEN_BIAS, &oldgreenbias);
+	_glGetFloatv(GL_BLUE_SCALE, &oldbluescale);
+	_glGetFloatv(GL_BLUE_BIAS, &oldbluebias);
+	_glGetFloatv(GL_ALPHA_SCALE, &oldalphascale);
+	_glGetFloatv(GL_ALPHA_BIAS, &oldalphabias);
 	_glPixelTransferf(GL_RED_SCALE, 1.0);
 	_glPixelTransferf(GL_RED_BIAS, 0.0);
 	_glPixelTransferf(GL_GREEN_SCALE, 1.0);
@@ -351,9 +360,19 @@ void pbdrawable::readpixels(GLint x, GLint y, GLint w, GLint pitch, GLint h,
 		putenv(_autotestframe);
 	}
 
-	glRenderMode(oldrendermode);
-	_glPopAttrib();
-	glPopClientAttrib();
+	if(oldrendermode!=GL_RENDER) glRenderMode(oldrendermode);
+
+	if(oldredscale!=1.0) _glPixelTransferf(GL_RED_SCALE, oldredscale);
+	if(oldredbias!=0.0) _glPixelTransferf(GL_RED_BIAS, oldredbias);
+	if(oldgreenscale!=1.0) _glPixelTransferf(GL_GREEN_SCALE, oldgreenscale);
+	if(oldgreenbias!=0.0) _glPixelTransferf(GL_GREEN_BIAS, oldgreenbias);
+	if(oldbluescale!=1.0) _glPixelTransferf(GL_BLUE_SCALE, oldbluescale);
+	if(oldbluebias!=0.0) _glPixelTransferf(GL_BLUE_BIAS, oldbluebias);
+	if(oldalphascale!=1.0) _glPixelTransferf(GL_ALPHA_SCALE, oldalphascale);
+	if(oldalphabias!=0.0) _glPixelTransferf(GL_ALPHA_BIAS, oldalphabias);
+
+	glPixelStorei(GL_PACK_ALIGNMENT, oldpackalignment);
+
 	tc.restore();
 
 	glReadBuffer(readbuf);
@@ -364,7 +383,11 @@ void pbdrawable::readpixels(GLint x, GLint y, GLint w, GLint pitch, GLint h,
 void pbdrawable::copypixels(GLint src_x, GLint src_y, GLint w, GLint h,
 	GLint dest_x, GLint dest_y, GLXDrawable draw)
 {
-	GLint readbuf=GL_BACK, drawbuf=GL_BACK, oldrendermode=GL_RENDER;
+	GLint readbuf=GL_BACK, drawbuf=GL_BACK, oldrendermode=GL_RENDER,
+		oldpackalignment=1, oldunpackalignment=1;
+	GLfloat oldredscale=1.0, oldredbias=0.0, oldgreenscale=1.0, oldgreenbias=0.0,
+		oldbluescale=1.0, oldbluebias=0.0, oldalphascale=1.0, oldalphabias=0.0;
+	GLint oldviewport[4];
 	GLint fbr=0, fbw=0;
 
 	glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING_EXT, &fbr);
@@ -374,7 +397,6 @@ void pbdrawable::copypixels(GLint src_x, GLint src_y, GLint w, GLint h,
 	_glGetIntegerv(GL_DRAW_BUFFER, &drawbuf);
 	_glGetIntegerv(GL_RENDER_MODE, &oldrendermode);
 
-
 	tempctx tc(_localdpy, draw, getglxdrawable(), glXGetCurrentContext(),
 		_config,
 		__vglServerVisualAttrib(_config, GLX_RENDER_TYPE) & GLX_COLOR_INDEX_BIT ?
@@ -384,11 +406,19 @@ void pbdrawable::copypixels(GLint src_x, GLint src_y, GLint w, GLint h,
 	_glDrawBuffer(GL_FRONT_AND_BACK);
 	glRenderMode(GL_RENDER);
 
-	glPushClientAttrib(GL_CLIENT_PIXEL_STORE_BIT);
-	glPushAttrib(GL_VIEWPORT_BIT|GL_COLOR_BUFFER_BIT|GL_PIXEL_MODE_BIT);
-
+	_glGetIntegerv(GL_UNPACK_ALIGNMENT, &oldunpackalignment);
+	_glGetIntegerv(GL_PACK_ALIGNMENT, &oldpackalignment);
 	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
 	glPixelStorei(GL_PACK_ALIGNMENT, 1);
+
+	_glGetFloatv(GL_RED_SCALE, &oldredscale);
+	_glGetFloatv(GL_RED_BIAS, &oldredbias);
+	_glGetFloatv(GL_GREEN_SCALE, &oldgreenscale);
+	_glGetFloatv(GL_GREEN_BIAS, &oldgreenbias);
+	_glGetFloatv(GL_BLUE_SCALE, &oldbluescale);
+	_glGetFloatv(GL_BLUE_BIAS, &oldbluebias);
+	_glGetFloatv(GL_ALPHA_SCALE, &oldalphascale);
+	_glGetFloatv(GL_ALPHA_BIAS, &oldalphabias);
 	_glPixelTransferf(GL_RED_SCALE, 1.0);
 	_glPixelTransferf(GL_RED_BIAS, 0.0);
 	_glPixelTransferf(GL_GREEN_SCALE, 1.0);
@@ -401,6 +431,7 @@ void pbdrawable::copypixels(GLint src_x, GLint src_y, GLint w, GLint h,
 	int e=glGetError();
 	while(e!=GL_NO_ERROR) e=glGetError();  // Clear previous error
 
+	_glGetIntegerv(GL_VIEWPORT, oldviewport);
 	_glViewport(0, 0, w, h);
 	glMatrixMode(GL_PROJECTION);
 	glPushMatrix();
@@ -422,9 +453,22 @@ void pbdrawable::copypixels(GLint src_x, GLint src_y, GLint w, GLint h,
 	glMatrixMode(GL_PROJECTION);
 	glPopMatrix();
 
-	glRenderMode(oldrendermode);
-	_glPopAttrib();
-	glPopClientAttrib();
+	_glViewport(oldviewport[0], oldviewport[1], oldviewport[2], oldviewport[3]);
+
+	if(oldrendermode!=GL_RENDER) glRenderMode(oldrendermode);
+
+	if(oldredscale!=1.0) _glPixelTransferf(GL_RED_SCALE, oldredscale);
+	if(oldredbias!=0.0) _glPixelTransferf(GL_RED_BIAS, oldredbias);
+	if(oldgreenscale!=1.0) _glPixelTransferf(GL_GREEN_SCALE, oldgreenscale);
+	if(oldgreenbias!=0.0) _glPixelTransferf(GL_GREEN_BIAS, oldgreenbias);
+	if(oldbluescale!=1.0) _glPixelTransferf(GL_BLUE_SCALE, oldbluescale);
+	if(oldbluebias!=0.0) _glPixelTransferf(GL_BLUE_BIAS, oldbluebias);
+	if(oldalphascale!=1.0) _glPixelTransferf(GL_ALPHA_SCALE, oldalphascale);
+	if(oldalphabias!=0.0) _glPixelTransferf(GL_ALPHA_BIAS, oldalphabias);
+
+	glPixelStorei(GL_UNPACK_ALIGNMENT, oldunpackalignment);
+	glPixelStorei(GL_PACK_ALIGNMENT, oldpackalignment);
+
 	tc.restore();
 
 	glReadBuffer(readbuf);
diff --git a/rr/pbwin.cpp b/rr/pbwin.cpp
index aab5349..bff5968 100644
--- a/rr/pbwin.cpp
+++ b/rr/pbwin.cpp
@@ -259,7 +259,7 @@ void pbwin::readback(GLint drawbuf, bool spoillast, bool sync)
 				rrout.println("[VGL]    Using anaglyphic stereo instead.");
 				message=true;
 			}
-			stereomode=RRSTEREO_REDCYAN;				
+			stereomode=RRSTEREO_REDCYAN;
 		}
 		else if(dostereo && !_stereovisual && stereomode==RRSTEREO_QUADBUF
 			&& strlen(fconfig.transport)==0)
@@ -334,6 +334,7 @@ void pbwin::sendplugin(GLint drawbuf, bool spoillast, bool sync,
 	if(_pb->format()==GL_BGRA_EXT) desiredformat=RRTRANS_BGRA;
 	#endif
 	if(_pb->format()==GL_RGBA) desiredformat=RRTRANS_RGBA;
+	if(!_truecolor) desiredformat=RRTRANS_INDEX;
 
 	frame=_plugin->getframe(pbw, pbh, desiredformat,
 		dostereo && stereomode==RRSTEREO_QUADBUF);
@@ -363,6 +364,19 @@ void pbwin::sendplugin(GLint drawbuf, bool spoillast, bool sync,
 	if(frame->format==RRTRANS_ABGR || frame->format==RRTRANS_ARGB)
 		glformat=GL_ABGR_EXT;
 	#endif
+	if(frame->format==RRTRANS_INDEX) glformat=GL_COLOR_INDEX;
+
+	if(dostereo && stereomode==RRSTEREO_QUADBUF && frame->rbits==NULL)
+	{
+		static bool message=false;
+		if(!message)
+		{
+			rrout.println("[VGL] NOTICE: Quad-buffered stereo is not supported by the plugin.");
+			rrout.println("[VGL]    Using anaglyphic stereo instead.");
+			message=true;
+		}
+		stereomode=RRSTEREO_REDCYAN;				
+	}
 	if(dostereo && stereomode==RRSTEREO_REDCYAN) makeanaglyph(&f, drawbuf);
 	else
 	{
diff --git a/rr/rrfakerut.cpp b/rr/rrfakerut.cpp
index 0135afc..baa604f 100644
--- a/rr/rrfakerut.cpp
+++ b/rr/rrfakerut.cpp
@@ -1253,6 +1253,12 @@ int vistest(void)
 	{
 		if(!(dpy=XOpenDisplay(0))) _throw("Could not open display");
 
+		// This will fail with VGL 2.2.x and earlier
+		if(!(configs=glXChooseFBConfig(dpy, DefaultScreen(dpy), NULL, &n))
+			|| n==0)
+			_throw("No FB configs found");
+		XFree(configs);  configs=NULL;
+
 		try
 		{
 			printf("RGBA:   ");
diff --git a/rr/rrtransport.h b/rr/rrtransport.h
index a5552c7..169a554 100644
--- a/rr/rrtransport.h
+++ b/rr/rrtransport.h
@@ -1,5 +1,5 @@
 /* Copyright (C)2005 Sun Microsystems, Inc.
- * Copyright (C)2009-2010 D. R. Commander
+ * Copyright (C)2009-2011 D. R. Commander
  *
  * This library is free software and may be redistributed and/or modified under
  * the terms of the wxWindows Library License, Version 3.1 or (at your option)
@@ -19,13 +19,13 @@
 #include "rr.h"
 
 // Pixel formats
-#define RRTRANS_FORMATOPT 6
+#define RRTRANS_FORMATOPT 7
 enum {RRTRANS_RGB, RRTRANS_RGBA, RRTRANS_BGR, RRTRANS_BGRA, RRTRANS_ABGR,
-      RRTRANS_ARGB};
+      RRTRANS_ARGB, RRTRANS_INDEX};
 
-static const int rrtrans_ps[RRTRANS_FORMATOPT]={3, 4, 3, 4, 4, 4};
-static const int rrtrans_bgr[RRTRANS_FORMATOPT]={0, 0, 1, 1, 1, 0};
-static const int rrtrans_afirst[RRTRANS_FORMATOPT]={0, 0, 0, 0, 1, 1};
+static const int rrtrans_ps[RRTRANS_FORMATOPT]={3, 4, 3, 4, 4, 4, 1};
+static const int rrtrans_bgr[RRTRANS_FORMATOPT]={0, 0, 1, 1, 1, 0, 0};
+static const int rrtrans_afirst[RRTRANS_FORMATOPT]={0, 0, 0, 0, 1, 1, 0};
 
 #if !defined(__SUNPRO_CC) && !defined(__SUNPRO_C)
 #pragma pack(1)
diff --git a/util/CMakeLists.txt b/util/CMakeLists.txt
index 58260ef..843eb6f 100644
--- a/util/CMakeLists.txt
+++ b/util/CMakeLists.txt
@@ -28,11 +28,16 @@ install(TARGETS nettest DESTINATION ${VGL_BINDIR})
 
 add_library(fbx STATIC fbx.c)
 
+if(VGL_BUILDSERVER)
+	add_library(fbx-faker STATIC fbx.c)
+	set_property(TARGET fbx-faker APPEND PROPERTY COMPILE_DEFINITIONS INFAKER)
+endif()
+
 add_executable(fbxtest fbxtest.cpp)
 if(WIN32)
-	target_link_libraries(fbxtest fbx)
+	target_link_libraries(fbxtest fbx rrutil)
 else()
-	target_link_libraries(fbxtest fbx -lpthread)
+	target_link_libraries(fbxtest fbx rrutil -lpthread)
 endif()
 
 if(WIN32 AND NOT CYGWIN)
@@ -42,7 +47,7 @@ if(WIN32 AND NOT CYGWIN)
 
 	add_executable(fbxtest-x11 fbxtest.cpp)
 	set_property(TARGET fbxtest-x11 APPEND PROPERTY COMPILE_DEFINITIONS FBXX11)
-	target_link_libraries(fbxtest-x11 fbx-x11)
+	target_link_libraries(fbxtest-x11 fbx-x11 rrutil)
 else()
 	target_link_libraries(fbx ${X11_X11_LIB} ${X11_Xext_LIB})
 endif()
diff --git a/util/fbx.c b/util/fbx.c
index 9112b0a..0c86fd4 100644
--- a/util/fbx.c
+++ b/util/fbx.c
@@ -59,6 +59,20 @@ const char *_fbx_formatname[FBX_FORMATS]=
 
 #endif
 
+#ifdef INFAKER
+
+typedef int (*_XCopyAreaType)(Display *, Drawable, Drawable, GC, int, int,
+	unsigned int, unsigned int, int, int);
+extern _XCopyAreaType __XCopyArea;
+
+#define XCopyArea(dpy, src, dst, gc, src_x, src_y, w, h, dest_x, dest_y) { \
+	if(!__XCopyArea) _throw("[FBX] ERROR: XCopyArea symbol not loaded"); \
+	__XCopyArea(dpy, src, dst, gc, src_x, src_y, w, h, dest_x, dest_y); \
+}
+
+#endif
+
+
 #ifdef FBXWIN32
 
  typedef struct _BMINFO {BITMAPINFO bmi;  RGBQUAD cmap[256];} BMINFO;
diff --git a/util/fbxtest.cpp b/util/fbxtest.cpp
index 02a2527..d5d714c 100644
--- a/util/fbxtest.cpp
+++ b/util/fbxtest.cpp
@@ -26,6 +26,11 @@
  #include <errno.h>
  #include "x11err.h"
 #endif
+#include "bmp.h"
+
+#ifdef _MSC_VER
+#define snprintf(str, n, format, ...) _snprintf_s(str, n, _TRUNCATE, format, __VA_ARGS__)
+#endif
 
 
 //////////////////////////////////////////////////////////////////////
@@ -56,7 +61,8 @@ int xhandler(Display *dpy, XErrorEvent *xe)
 #define N                 2
 
 int width, height;
-int checkdb=0, doshm=1;
+int checkdb=0, doshm=1, dofs=0, dovid=0, dodisplay=0, interactive=0,
+	advance=0;
 #ifndef FBXWIN32
 int dopixmap=0;
 Window win=0;
@@ -69,6 +75,9 @@ rrtimer timer;
 #define fg()
 #endif
 
+const BMPPIXELFORMAT fb2bmpformat[FBX_FORMATS]=
+	{BMP_RGB, BMP_RGBX, BMP_BGR, BMP_BGRX, BMP_XBGR, BMP_XRGB, BMP_RGB};
+
 void nativeread(int), nativewrite(int);
 
 //////////////////////////////////////////////////////////////////////
@@ -412,15 +421,146 @@ LRESULT CALLBACK WndProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
 		case WM_CLOSE:
 			PostQuitMessage(0);
 			return 0;
+		case WM_CHAR:
+			if((wParam==27 || wParam=='q' || wParam=='Q') && dovid)
+			{
+				PostQuitMessage(0);
+				return 0;
+			}
+			break;
 		case WM_PAINT:
-			display();
-			PostQuitMessage(0);
+			if(!dovid)
+			{
+				display();
+				PostQuitMessage(0);
+			}
+			else
+			{
+				if(interactive) dodisplay=1;
+				return 0;
+			}
+			break;
+		case WM_MOUSEMOVE:
+			if((wParam & MK_LBUTTON) && dovid && interactive)
+			{
+				dodisplay=advance=1;
+				return 0;
+			}
+			break;
 	}
 	return DefWindowProc(hwnd, iMsg, wParam, lParam);
 }
 #endif
 
 
+void event_loop(void)
+{
+	fbx_struct fb[10];
+	int frame=0, inc=-1, first=1;
+	unsigned long frames=0;
+	rrtimer timer;
+	double elapsed, mpixels=0.;
+	char temps[256];
+
+	for(int i=0; i<10; i++)
+	{
+		memset(&fb[i], 0, sizeof(fb[i]));
+	}
+
+	try {
+
+	for(int i=0; i<10; i++)
+	{
+		fbx(fbx_init(&fb[i], wh, 0, 0, doshm));
+		snprintf(temps, 256, "frame%d.ppm", i);
+		unsigned char *buf=NULL;  int tempw=0, temph=0;
+		if(loadbmp(temps, &buf, &tempw, &temph, fb2bmpformat[fb[i].format],
+			1, 0)==-1)
+			_throw(bmpgeterr());
+		int ps=fbx_ps[fb[i].format];
+		for(int j=0; j<min(temph, fb[i].height); j++)
+			memcpy(&fb[i].bits[fb[i].pitch*j], &buf[tempw*ps*j],
+				min(tempw, fb[i].width)*ps);
+		free(buf);
+	}
+
+	timer.start();
+	while (1)
+	{
+		advance=0;  dodisplay=0;
+		if(first) {dodisplay=1;  first=0;}
+
+		#ifdef FBXWIN32
+
+		int ret;  MSG msg;
+		if((ret=GetMessage(&msg, NULL, 0, 0))==-1)
+			{_throww32();}
+		else if(ret==0) break;
+		TranslateMessage(&msg);
+		DispatchMessage(&msg);
+
+		#else
+
+		while(1)
+		{
+			XEvent event;
+			if(XPending(wh.dpy)>0) XNextEvent(wh.dpy, &event);
+			else break;
+			switch (event.type)
+			{
+				case Expose:
+					dodisplay=1;
+					break;
+				case KeyPress:
+				{
+					char buf[10];  int key;
+					key=XLookupString(&event.xkey, buf, sizeof(buf), NULL, NULL);
+					switch(buf[0])
+					{
+						case 27: case 'q': case 'Q':
+							return;
+					}
+					break;
+				}
+				case MotionNotify:
+					if(event.xmotion.state & Button1Mask) dodisplay=advance=1;
+ 					break;
+			}
+		}
+
+		#endif
+
+		if(!interactive || dodisplay)
+		{
+			fbx(fbx_write(&fb[frame], 0, 0, 0, 0, 0, 0));
+			if(!interactive || advance)
+			{
+				if(frame==0 || frame==9) inc=-1*inc;
+				frame+=inc;  frames++;
+				mpixels+=(double)fb[frame].width*(double)fb[frame].height/1000000.;
+
+				if((elapsed=timer.elapsed())>2.0)
+				{
+					snprintf(temps, 256, "%f frames/sec - %f Mpixels/sec",
+						(double)frames/elapsed, mpixels/elapsed);
+					printf("%s\n", temps);
+					timer.start();  mpixels=0.;  frames=0;
+				}
+			}
+		}
+	}
+
+	for(int i=0; i<10; i++) fbx_term(&fb[i]);
+
+	} catch(...)
+	{
+		for(int i=0; i<10; i++) fbx_term(&fb[i]);
+		throw;
+	}
+
+}
+
+
 void usage(char *progname)
 {
 	fprintf(stderr, "USAGE: %s [options]\n\n", progname);
@@ -428,7 +568,8 @@ void usage(char *progname)
 	fprintf(stderr, "-checkdb = Verify that double buffering is working correctly\n");
 	fprintf(stderr, "-noshm = Do not use MIT-SHM extension to accelerate blitting\n");
 	fprintf(stderr, "-pm = Blit to a pixmap rather than to a window\n");
-	fprintf(stderr, "-v = Print all warnings and informational messages from FBX\n\n");
+	fprintf(stderr, "-v = Print all warnings and informational messages from FBX\n");
+	fprintf(stderr, "-fs = Full-screen mode\n\n");
 	exit(1);
 }
 
@@ -437,6 +578,9 @@ void usage(char *progname)
 //////////////////////////////////////////////////////////////////////
 int main(int argc, char **argv)
 {
+	#ifdef FBXWIN32
+	int winstyle=WS_OVERLAPPED | WS_SYSMENU | WS_CAPTION | WS_VISIBLE;
+	#endif
 	int i;
 
 	fprintf(stderr, "\n%s v%s (Build %s)\n\n", bench_name, __VERSION, __BUILD);
@@ -453,16 +597,25 @@ int main(int argc, char **argv)
 		{
 			doshm=0;
 		}
-		if(!strnicmp(argv[i], "-v", 2))
+		if(!stricmp(argv[i], "-vid")) dovid=1;
+		else if(!strnicmp(argv[i], "-v", 2))
 		{
 			fbx_printwarnings(stderr);
 		}
+		if(!stricmp(argv[i], "-i")) interactive=1;
 		#ifndef FBXWIN32
 		if(!stricmp(argv[i], "-pm"))
 		{
 			dopixmap=1;  doshm=0;
 		}
 		#endif
+		if(!stricmp(argv[i], "-fs"))
+		{
+			dofs=1;
+			#ifdef FBXWIN32
+			winstyle=WS_EX_TOPMOST | WS_POPUP | WS_VISIBLE;
+			#endif
+		}
 		if(!strnicmp(argv[i], "-h", 2) || !stricmp(argv[i], "-?")) usage(argv[0]);
 	}
 
@@ -502,18 +655,24 @@ int main(int argc, char **argv)
 		fprintf(stderr, "ERROR: Please switch to a screen resolution of at least %d x %d.\n", MIN_SCREEN_WIDTH, MIN_SCREEN_HEIGHT);
 		exit(1);
 	}
-	width=WIDTH;
-	height=HEIGHT;
+	if(!dofs)
+	{
+		width=WIDTH;
+		height=HEIGHT;
+	}
 
 	#ifdef FBXWIN32
 
 	int bw=GetSystemMetrics(SM_CXFIXEDFRAME)*2;
 	int bh=GetSystemMetrics(SM_CYFIXEDFRAME)*2+GetSystemMetrics(SM_CYCAPTION);
-	tryw32(wh=CreateWindowEx(0, bench_name, bench_name, WS_OVERLAPPED |
-		WS_SYSMENU | WS_CAPTION | WS_VISIBLE, 0,  0, width+bw, height+bh, NULL,
-		NULL, GetModuleHandle(NULL), NULL));
+	tryw32(wh=CreateWindowEx(0, bench_name, bench_name, winstyle, 0, 0, width+bw,
+		height+bh, NULL, NULL, GetModuleHandle(NULL), NULL));
 	UpdateWindow(wh);
 	BOOL ret;
+	if(dovid)
+	{
+		event_loop();  return 0;
+	}
 	while(1)
 	{
 		if((ret=GetMessage(&msg, NULL, 0, 0))==-1) _throww32();
@@ -532,26 +691,37 @@ int main(int argc, char **argv)
 	vtemp.depth=24;  vtemp.c_class=TrueColor;
 	if((v=XGetVisualInfo(wh.dpy, VisualDepthMask|VisualClassMask, &vtemp, &n))!=NULL && n!=0)
 	{
+		int mask=CWBorderPixel|CWColormap|CWEventMask;
 		swa.colormap=XCreateColormap(wh.dpy, root, v->visual, AllocNone);
 		swa.border_pixel=0;
 		swa.event_mask=0;
+		if(dofs)
+		{
+			mask|=CWOverrideRedirect;  swa.override_redirect=True;
+		}
+		if(dovid)
+		{
+			if(interactive)
+				swa.event_mask|=PointerMotionMask|ButtonPressMask|ExposureMask;
+			swa.event_mask|=KeyPressMask;
+		}
 		if(dopixmap)
 		{
-			errifnot(win=XCreateWindow(wh.dpy, root, 0, 0, 1, 1, 0,
-				v->depth, InputOutput, v->visual, CWBorderPixel|CWColormap|CWEventMask,
-				&swa));
+			errifnot(win=XCreateWindow(wh.dpy, root, 0, 0, 1, 1, 0, v->depth,
+				InputOutput, v->visual, mask, &swa));
 			errifnot(wh.d=XCreatePixmap(wh.dpy, win, width, height, v->depth));
 			wh.v=v->visual;
 		}
 		else
 		{
 			errifnot(wh.d=XCreateWindow(wh.dpy, root, 0, 0, width, height, 0,
-				v->depth, InputOutput, v->visual, CWBorderPixel|CWColormap|CWEventMask,
-				&swa));
+				v->depth, InputOutput, v->visual, mask, &swa));
 			errifnot(XMapRaised(wh.dpy, wh.d));
 		}
+		if(dofs) XSetInputFocus(wh.dpy, wh.d, RevertToParent, CurrentTime);
 		XSync(wh.dpy, False);
-		display();
+		if(dovid) event_loop();
+		else display();
 		if(dopixmap)
 		{
 			XFreePixmap(wh.dpy, wh.d);
@@ -562,6 +732,8 @@ int main(int argc, char **argv)
 	}
 	else fprintf(stderr, "No RGB visuals available.  Skipping those tests.\n\n");
 
+	if(dovid) return 0;
+
 	vtemp.depth=8;  vtemp.c_class=PseudoColor;
 	if((v=XGetVisualInfo(wh.dpy, VisualDepthMask|VisualClassMask, &vtemp, &n))!=NULL && n!=0)
 	{
diff --git a/util/rrsocket.cpp b/util/rrsocket.cpp
index 6ac1d88..43d6e17 100644
--- a/util/rrsocket.cpp
+++ b/util/rrsocket.cpp
@@ -331,7 +331,7 @@ rrsocket *rrsocket::accept(void)
 	if(_dossl)
 	{
 		if(!(tempssl=SSL_new(_sslctx))) _throwssl();
-		if(!(SSL_set_fd(tempssl, sd_client))) _throwssl();
+		if(!(SSL_set_fd(tempssl, (int)sd_client))) _throwssl();
 		int ret=SSL_accept(tempssl);
 		if(ret!=1) throw(sslerror("rrsocket::accept", tempssl, ret));
 		SSL_set_accept_state(tempssl);
